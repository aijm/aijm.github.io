<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vscode java 配置]]></title>
    <url>%2F2018%2F12%2F28%2Fvscode-java-%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[java in vscode 插件安装安装 Java Extension Pack 插件,会自动安装以下四个插件： Language Support for Java(TM) by Red Hat Debugger for Java Java Test Runner Maven for Java在vscode中可以通过以上插件配置java编程环境。但是如果不用maven、gradle等项目构建工具，后两个插件是无法使用的，而且对于简单的仅有.java文件的项目结构，就我找遍各种资料，也没有找到导入jar包的方法，自动识别文件内容有时也会出错。配置jdk路径打开settings.json，在用户设置中添加 &quot;java.home&quot;: &quot;D:\\Program Files\\Java\\jdk-11.0.1&quot;， run and debug 找不到依赖文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class NBody&#123; /** return the radius of the universe in file */ public static double readRadius(String filename)&#123; double radius=0; try&#123; In in = new In(filename); in.readInt(); radius = in.readDouble(); &#125; catch(Exception e)&#123; System.out.println(e); &#125; // System.out.println("Read file " + filename + " successful!"); return radius; &#125; /** return an array of planets from file */ public static Planet[] readPlanets(String filename)&#123; Planet[] planets = null; try&#123; In in = new In(filename); int N = in.readInt(); in.readDouble(); /** construct planets array */ planets = new Planet[N]; for(int i=0;i&lt;N;i++)&#123; double xP = in.readDouble(); double yP = in.readDouble(); double xV = in.readDouble(); double yV = in.readDouble(); double m = in.readDouble(); String img = in.readString(); planets[i] = new Planet(xP, yP, xV, yV, m, img); &#125; System.out.println("Read file " + filename + " successful!"); &#125; catch(Exception e)&#123;System.out.println(e);&#125; System.out.println(); return planets; &#125; public static void main(String[] args) &#123; double T = Double.parseDouble(args[0]); double dt = Double.parseDouble(args[1]); String filename = args[2]; double radius = readRadius(filename); Planet[] planets = readPlanets(filename); StdAudio.play("./audio/2001.mid"); StdDraw.setScale(-radius,radius); StdDraw.enableDoubleBuffering(); double time = 0; while(time &lt; T)&#123; double[] xForces = new double[planets.length]; double[] yForces = new double[planets.length]; /** save the forces to xForces and yFroces arrays */ for(int i=0;i&lt;planets.length;i++)&#123; xForces[i] = planets[i].calcNetForceExertedByX(planets); yForces[i] = planets[i].calcNetForceExertedByY(planets); &#125; /** update all planets */ for(int i=0;i&lt;planets.length;i++)&#123; planets[i].update(dt, xForces[i], yForces[i]); &#125; StdDraw.clear(); /** draw image background */ StdDraw.picture(0, 0, "./images/starfield.jpg"); /** draw all the planets */ for(Planet p : planets)&#123; p.draw(); &#125; StdDraw.show(); StdDraw.pause(10); time += dt; &#125; StdOut.printf("%d\n", planets.length); StdOut.printf("%.2e\n", radius); for (int i = 0; i &lt; planets.length; i++) &#123; StdOut.printf("%11.4e %11.4e %11.4e %11.4e %11.4e %12s\n", planets[i].xxPos, planets[i].yyPos, planets[i].xxVel, planets[i].yyVel, planets[i].mass, planets[i].imgFileName); &#125; &#125;&#125; 上面的java程序依赖In, Planet, StdAudio,StdDraw,StdOut 而进行Run/Debug时会报错，找不到In,StdAudio等，但是把对应java文件双击打开后，运行正常。 需要命令行参数，则配置launch.json中的”args”1234567891011&#123; "configurations": [ &#123; "type": "java", "name": "CodeLens (Launch) - NBody", "request": "launch", "mainClass": "NBody", "args": "157788000.0 25000.0 data/planets.txt" &#125; ]&#125; library path不用maven什么的话，现在没有办法加载库，通过calssPath也不行。]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cs61c project1-1 Shape from Stereo, in C]]></title>
    <url>%2F2018%2F12%2F26%2Fcs61c-project1-1-Shape-from-Stereo-in-C%2F</url>
    <content type="text"><![CDATA[CUnit]]></content>
  </entry>
  <entry>
    <title><![CDATA[cs61c_hw2]]></title>
    <url>%2F2018%2F12%2F25%2Fcs61c-hw2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[cs61c_lab3-RISC-V]]></title>
    <url>%2F2018%2F12%2F25%2Fcs61c-lab3%2F</url>
    <content type="text"><![CDATA[link of cs61c_lab3 lab3 lab3_ex1.s1234567891011121314151617181920.data.word 2, 4, 6, 8n: .word 9.textmain: add t0, x0, x0 addi t1, x0, 1 la t3, n lw t3, 0(t3)fib: beq t3, x0, finish add t2, t1, t0 mv t0, t1 mv t1, t2 addi t3, t3, -1 j fibfinish: addi a0, x0, 1 addi a1, t0, 0 ecall # print integer ecall addi a0, x0, 10 ecall # terminate ecall Exercise 1: Familiarizing yourself with Venus What do the .data, .word, .text directives mean (i.e. what do you use them for)? Hint: think about the 4 sections of memory. .data 是表示 static data 区域，而其中的.word表示静态全局数据区域的32位字；.text表示指令区域 Run the program to completion. What number did the program output? What does this number represent? 34， 菲波那切数列中的第9个(从0开始数)。 0,1,1,2,3,5,8,13,21,34 At what address is n stored in memory? Hint: Look at the contents of the registers. 0x10000010 Without using the “Edit” tab, have the program calculate the 13th fib number (0-indexed) by manually modifying the value of a register. You may find it helpful to first step through the code. If you prefer to look at decimal values, change the “Display Settings” option at the bottom. 只需在 lw t3, 0(t3) 之后把寄存器 x28 的值改为 0x0000000D,即13 Exercise 2: Translating from C to RISC-VTask: Find/explain the following components of this assembly file.lab3_ex2_assembly.s123456789101112131415161718192021222324252627282930313233343536373839.datasource: .word 3 .word 1 .word 4 .word 1 .word 5 .word 9 .word 0dest: .word 0 .word 0 .word 0 .word 0 .word 0 .word 0 .word 0 .word 0 .word 0 .word 0.textmain: addi t0, x0, 0 # int k = 0; la t1, source # pointer to source la t2, dest # pointer to destloop: slli t3, t0, 2 # 32bit,so offset is 4*k add t4, t1, t3 lw t5, 0(t4) # int temp = source[k]; beq t5, x0, exit # while(source[k]!=0) add t6, t2, t3 sw t5, 0(t6) # dest[k] = temp; addi t0, t0, 1 # k++; jal x0, loop exit: addi a0, x0, 10 add a1, x0, x0 ecall # Terminate ecall The register representing the variable k. t0 The registers acting as pointers to the source and dest arrays. t1 –&gt; source, t2 –&gt; dest The assembly code for the loop found in the C code. 123456789loop: slli t3, t0, 2 # 32bit,so offset is 4*k add t4, t1, t3 lw t5, 0(t4) # int temp = source[k]; beq t5, x0, exit # while(source[k]!=0) add t6, t2, t3 sw t5, 0(t6) # dest[k] = temp; addi t0, t0, 1 # k++; jal x0, loop How the pointers are manipulated in the assembly code. &amp;取地址，用la, 地址存在寄存器中，通过地址加减移位运算移动指针，通过lw,sw来实现取值和赋值 Exercise 4: RISC-V function calling with mapC语言形式：123456789101112struct node&#123; int value; struct node* next;&#125;;void map(node *head, int (*f)(int))&#123; if(!head)&#123; return; &#125; head-&gt;value = f(head-&gt;value); map(head-&gt;next,f);&#125; 用RISC-V来写以上代码，下文仅包含简略部分：关键点： 函数调用步骤 参数存入a0,a1,… 调用时需要保存return address, 需要保存的寄存器的值；存储这些值是因为调用的函数可能会改变这些值。 上面的值通过栈来保存，就是所谓的调用栈 通过 jal ra, func 调用函数，这条语句会把ra的值+4,得到下一条指令的地址，同时把pc的值变为函数func的地址 执行函数，通过a0返回值，在最后 jr ra, 会将pc的值变为ra,返回到之前调用处的下一条指令 函数调用后，从栈中恢复原来保存的值，通过sp增加回收栈空间 例如以下是调用f(head-&gt;value)的RISC-V代码12345678addi sp, sp, -4sw ra, 0(sp) # save ralw a0, 0(s0) # node value as aug jalr ra, a1, 0 # fun(node value)lw ra, 0(sp) # restore raaddi sp, sp, 4 # toss off stack 尾调用例如类似以下函数：12345678910// example1void f()&#123; ... return g(a,b);&#125;// example2void f()&#123; ... return 1+g(a,b)&#125; example1中函数g(a,b)调用后就返回，所以不需要产生调用栈，直接调用g,jal x0, g,然后在g(a,b)中 jr ra即可。 尾递归尾递归就是递归调用是尾调用的递归。普通的递归程序由于不断调用产生调用栈，调用层数太多时容易产生栈溢出，而尾递归却不会。比如map程序就是一个尾递归，内部调用时应该用jal x0, map, 而不是jal ra,map1234567891011121314151617181920212223242526map: beq a0, x0, done # If we were given a null pointer (address 0), we're done. add s0, a0, x0 # Save address of this node in s0 add s1, a1, x0 # Save address of function in s1 # load the value of the current node into a0 lw a0, 0(s0) # node value as aug # 调用函数f,产生调用栈 addi sp, sp, -4 sw ra, 0(sp) # func call need to save ra jalr ra, a1, 0 # fun(node value) lw ra, 0(sp) # restore ra addi sp, sp, 4 # toss off stack # store the returned value back into the node sw a0, 0(s0) # change node value # Load the address of the next node into a0 lw a0, 4(s0) # next node mv a1, s1 jal x0, map # 尾调用不需要用栈存储返回地址、寄存器值，不会产生调用栈done: jr ra # Return to caller]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>cs61c</tag>
        <tag>尾递归</tag>
        <tag>RISC-V</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cs61c_lab2]]></title>
    <url>%2F2018%2F12%2F25%2Fcs61c-lab2%2F</url>
    <content type="text"><![CDATA[link of cs61b lab2 lab2 Exercise1:Bit Operations给一个unsigned int的数，如何只通过与(&amp;), 或(|), 非(~), 异或(^), 逻辑左移(&lt;&lt;), 逻辑右移(&gt;&gt;),来实现三个函数。123456789101112131415// Return the nth bit of x.// Assume 0 &lt;= n &lt;= 31unsigned get_bit(unsigned x, unsigned n);// Set the nth bit of the value of x to v.// Assume 0 &lt;= n &lt;= 31, and v is 0 or 1void set_bit(unsigned * x, unsigned n, unsigned v);// Flip the nth bit of the value of x.// Assume 0 &lt;= n &lt;= 31void flip_bit(unsigned * x, unsigned n); 要实现这三个操作，关键是利用任何数与111…1进行与，结果是其自身。任何数与000…0进行或，结果是其自身。 get_bit123unsigned get_bit(unsigned x, unsigned n)&#123; return (x&gt;&gt;n) &amp; 0x1;&#125; set_bit1234567void set_bit(unsigned * x, unsigned n, unsigned v) &#123; (*x) = (*x) &amp; ~(0x1 &lt;&lt; n); // 和111...0...111与将n位置变成0 (*x) = (*x) | (v&lt;&lt;n); // 和0000...v...0000或 &#125; flip_bit因为 1^1 = 0,1^0 = 1,所以 1^a = ~a,所以filp可以通过与1进行^操作实现；又因为1^0 = 1, 0^0 = 0, 所以 a^0 = a, 所以与0异或保持不变，则用mask 000...1...000异或即可12345void flip_bit(unsigned * x, unsigned n) &#123; (*x) = (*x) ^ (1&lt;&lt;n); &#125; 线性反馈移位寄存器linear feedback shift register, 例如一个16位寄存器x，每次对各个位进行特定的线性运算，得到一个新的值a=0 或 1，然后x右移1位，首位变成a,如此不断运算，最后能遍历所有16位数，由于每次的操作具有一定的随机性，可以用于生成伪随机数。伪随机数是因为只要初始值给定，后面得到的每个值都是固定的，所以常常需要设置不同的初始值(随机数种子)。例如上图，每次对0,2,3,5的位进行异或运算，移位后将最高位设为计算得到的值。123456789void lfsr_calculate(uint16_t *reg)&#123; uint16_t reg_0 = (*reg) &amp; 0x1u; uint16_t reg_2 = ((*reg) &gt;&gt; 2) &amp; 0x1u; uint16_t reg_3 = ((*reg) &gt;&gt; 3) &amp; 0x1u; uint16_t reg_5 = ((*reg) &gt;&gt; 5) &amp; 0x1u; uint16_t shift_in = ((reg_0^reg_2)^reg_3)^reg_5; *reg = *reg &gt;&gt; 1; // right shift 1 bit *reg = (*reg) | (shift_in &lt;&lt; 15); // shift in&#125;]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>cs61c</tag>
        <tag>线性反馈移位寄存器</tag>
        <tag>位操作</tag>
        <tag>伪随机数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cs61c_lab1]]></title>
    <url>%2F2018%2F12%2F23%2Fcs61c-lab1%2F</url>
    <content type="text"><![CDATA[Exercise 1: Binary Alphabet123450 1 1 0 □ ■ ■ □1 0 0 1 ■ □ □ ■1 1 1 1 --&gt; ■ ■ ■ ■1 0 0 1 ■ □ □ ■1 0 0 1 ■ □ □ ■ checkoff: What five decimal digits produce the pattern above? What five hexadecimal digits? What letter is drawn with 1,1,9,9,6? 0xF8F88? What is the hexadecimal representation you would use to spell the letter ‘B’? ‘N’ (you probably won’t want to use 5 hex digits for this one)? answer: 十进制 6,9,15,9,9; 十六进制 0x6,0x9,0xF,0x9,0x9–&gt;0x69F99 1,1,9,9,6–&gt;J; 0xF8F88–&gt;F 见图：0xE9E9E–&gt;B;0x9DB90–&gt;N123456789101112B■ ■ ■ □■ □ □ ■■ ■ ■ □■ □ □ ■■ ■ ■ □N■ □ □ ■■ ■ □ ■■ □ ■ ■■ □ □ ■□ □ □ □ Exercise 2: Simple C Programcheckoff: Explain the changes you made. Explain the minimum number of distinct values needed for the preprocessor macros. What does the -o flag do with gcc? answer: V0=3,V1=3,V3=3,V2!=0 3 gcc -o &lt;file&gt; –&gt; Place the executable output into file Exercise 3: Debugger How do you pass command line arguments to a program when using gdb?run arg1 arg2 ... How do you set a breakpoint which only occurs when a set of conditions is true (e.g. when certain variables are a certain value)?b file:line if &lt;condition&gt; How do you execute the next line of C code in the program after stopping at a breakpoint?next If the next line of code is a function call, you’ll execute the whole function call at once if you use your answer to #3. (If not, consider a different command for #3!) How do you tell GDB that you want to debug the code inside the function instead? (If you changed your answer to #3, then that answer is most likely now applicable here.)step How do you resume the program after stopping at a breakpoint?INTERRUPT or Ctrl+c How can you see the value of a variable (or even an expression like 1+2) in gdb?p &lt;exp&gt; How do you configure gdb so it prints the value of a variable after every step?display &lt;variable&gt; How do you print a list of all variables and their values in the current function?info args, info locals, info variables How do you exit out of gdb?quit Exercise 4,5,6 C program requires user input: how to run or gdb without geting stuck?通过重定向方法，重定向输入输出流stdin和stdout为文件，如：./a.out &lt; intput.txt &gt; output.txt，对于gdb,则是run &lt; input.txt &gt; output.txt how to check if a linked list has a cycle? (tortoise and hare)]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>cs61c</tag>
        <tag>gdb</tag>
        <tag>cgdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cs61c_lab0]]></title>
    <url>%2F2018%2F12%2F23%2Fcs61c-lab0%2F</url>
    <content type="text"><![CDATA[问题和任务lab0给了一个文件夹，目录如下：12345aijm@DESKTOP-R8SS06A:/mnt/d/学习/cs61c/lab00$ tree -L 1.├── bin├── config└── user 其中 bin 目录存储了一些程序，config 包含 users.list 和 users.list.bak, user 包含各个不同用户的目录，每个用户目录下都有init.d文件夹。 问题背景是，当黑客侵入系统时，会将他的username 加入到配置文件 users.list中，而users.list每次更改都会产生一个备份，users.list.bak. 任务1： 找出侵入系统的用户方法是比较users.list 和 users.list.bak,查看其中的不同,可以使用 diff 和 sdiff命令： sdiff1usage: sdiff [ -l | -s ][ -o OutFile] [ -w Number ]File1 File2 则通过 -s 选项仅仅输出不同的行：12aijm@DESKTOP-R8SS06A:/mnt/d/学习/cs61c/lab00/config$ sdiff -s users.list users.list.baksonicspaceman 则可以知道，入侵者的用户名是: sonicspaceman,一个非常骚气的名字。。。 这个入侵者可能会修改已有的程序，或者植入自己的程序，我们需要找出bin目录下的这些程序。 任务2： 找出入侵者可能修改、植入的程序方法是通过查看users.list的修改时间，再看bin目录下程序的修改时间，找出可能的程序。 通过stat命令查看文件时间戳：1234567891011121314151617aijm@DESKTOP-R8SS06A:/mnt/d/学习/cs61c/lab00/config$ stat * File: users.list Size: 91687 Blocks: 184 IO Block: 4096 regular fileDevice: dh/13d Inode: 562949954017106 Links: 1Access: (0777/-rwxrwxrwx) Uid: ( 1000/ aijm) Gid: ( 1000/ aijm)Access: 2018-12-23 01:23:28.098195800 +0800Modify: 2018-08-21 06:41:30.000000000 +0800Change: 2018-12-23 00:07:05.114099700 +0800 Birth: - File: users.list.bak Size: 91673 Blocks: 184 IO Block: 4096 regular fileDevice: dh/13d Inode: 562949954017107 Links: 1Access: (0777/-rwxrwxrwx) Uid: ( 1000/ aijm) Gid: ( 1000/ aijm)Access: 2018-12-23 01:22:12.619836900 +0800Modify: 2018-08-21 06:40:48.000000000 +0800Change: 2018-12-23 00:07:05.114099700 +0800 Birth: - 可以看到 users.list 在 Modify: 2018-08-21 06:41:30.000000000 +0800 被修改，于是在bin目录下，可以让文件按修改时间进行排序：用 ls -lat,按修改时间排序：123456789101112131415161718192021222324252627282930313233343536aijm@DESKTOP-R8SS06A:/mnt/d/学习/cs61c/lab00/bin$ ls -lattotal 4116drwxrwxrwx 1 aijm aijm 4096 Dec 23 00:08 ..drwxrwxrwx 1 aijm aijm 4096 Dec 23 00:08 .-rwxrwxrwx 1 aijm aijm 182352 Aug 21 06:44 dog-rwxrwxrwx 1 aijm aijm 182352 Aug 21 06:43 sudo-rwxrwxrwx 1 aijm aijm 34888 Aug 21 06:39 bzip2-rwxrwxrwx 1 aijm aijm 59608 Aug 21 06:39 chmod-rwxrwxrwx 1 aijm aijm 67768 Aug 21 06:39 chown-rwxrwxrwx 1 aijm aijm 72000 Aug 21 06:39 dmesg-rwxrwxrwx 1 aijm aijm 35000 Aug 21 06:39 echo-rwxrwxrwx 1 aijm aijm 51512 Aug 21 06:39 ed-rwxrwxrwx 1 aijm aijm 133792 Aug 21 06:39 ls-rwxrwxrwx 1 aijm aijm 80056 Aug 21 06:39 mkdir-rwxrwxrwx 1 aijm aijm 38952 Aug 21 06:39 more-rwxrwxrwx 1 aijm aijm 137440 Aug 21 06:39 mv-rwxrwxrwx 1 aijm aijm 423384 Aug 21 06:39 tar-rwxrwxrwx 1 aijm aijm 88280 Aug 21 06:39 touch-rwxrwxrwx 1 aijm aijm 1113504 Aug 21 06:37 bash-rwxrwxrwx 1 aijm aijm 63672 Aug 21 06:37 chgrp-rwxrwxrwx 1 aijm aijm 219528 Aug 21 06:37 grep-rwxrwxrwx 1 aijm aijm 2301 Aug 21 06:37 gunzip-rwxrwxrwx 1 aijm aijm 26704 Aug 21 06:37 kill-rwxrwxrwx 1 aijm aijm 170760 Aug 21 06:37 less-rwxrwxrwx 1 aijm aijm 245872 Aug 21 06:37 nano-rwxrwxrwx 1 aijm aijm 63704 Aug 21 06:37 rm-rwxrwxrwx 1 aijm aijm 109000 Aug 21 06:37 sed-rwxrwxrwx 1 aijm aijm 35032 Aug 21 06:37 uname-rwxrwxrwx 1 aijm aijm 946 Aug 21 06:37 which-rwxrwxrwx 1 aijm aijm 35064 Aug 21 06:35 cat-rwxrwxrwx 1 aijm aijm 141528 Aug 21 06:35 cp-rwxrwxrwx 1 aijm aijm 100568 Aug 21 06:35 date-rwxrwxrwx 1 aijm aijm 101560 Aug 21 06:35 gzip-rwxrwxrwx 1 aijm aijm 67808 Aug 21 06:35 ln-rwxrwxrwx 1 aijm aijm 35000 Aug 21 06:35 pwd-rwxrwxrwx 1 aijm aijm 35000 Aug 21 06:35 sleep 可以看到，有dog和sudo的更改发生在入侵之后。 入侵者往往不会仅仅简单的修改程序、植入程序，还常常修改配置文件，使某些用户登录后自动执行这些程序。user目录下的init.d目录有许多程序，这些程序会在用户登录后自启动，所以需要查看这些程序中是否包含之前的可疑程序。 任务3: 找出各个用户init.d目录下可能被污染的程序方法是找出所有文件中包含&quot;dog&quot;,&quot;sudo&quot;字符串的位置。 grepgrep 是一个非常强大的文本搜索工具，常见用法如下：12345678910111213141516Grep选项：* : 表示当前目录所有文件，也可以是某个文件名-r 是递归查找-n 是显示行号-R 查找所有文件包含子目录-i 忽略大小写有意思的命令行参数：grep -E &apos;123|abc&apos; filename : 找出文件（filename）中包含123或者包含abc的行grep -i pattern files ：不区分大小写地搜索。默认情况区分大小写grep -l pattern files ：只列出匹配的文件名,不列出路径grep -L pattern files ：列出不匹配的文件名grep -w pattern files ：只匹配整个单词，而不是字符串的一部分（如匹配‘magic’，而不是‘magical’）grep -C number pattern files ：匹配的上下文分别显示[number]行grep pattern1 | pattern2 files ：显示匹配 pattern1 或 pattern2 的行grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配 pattern2 的行 所以，可以运行如下命令：123456aijm@DESKTOP-R8SS06A:/mnt/d/学习/cs61c/lab00/user$ grep -E -rn 'dog|sudo' ././crealex/init.d/dbus:69: dog./konotacja/init.d/networking:49: sudo log_failure_msg "can't create $RUN_DIR"./oeufmayo/init.d/x11-common:98: dog./Qondanisa/init.d/networking:169: dog./Thiesi/init.d/rsync:87: sudo dog 则找出了包含&quot;dog&quot;,&quot;sudo&quot;的位置。 任务4: 删除这些文件，或文件中有问题的行sed 转载自Linux Shell中删除和替换文件中某一行的方法 sed是一个很好的文件处理工具，本身是一个管道命令，主要是以行为单位进行处理，可以将数据行进行替换、删除、新增、选取等特定工作，下面先了解一下sed的用法sed命令行格式为： sed [-nefri] ‘command’ 输入文本 常用选项：12345-n∶使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN的资料一般都会被列出到萤幕上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。-e∶直接在指令列模式上进行 sed 的动作编辑；-f∶直接将 sed 的动作写在一个档案内， -f filename 则可以执行 filename 内的sed 动作；-r∶sed 的动作支援的是延伸型正规表示法的语法。(预设是基础正规表示法语法)-i∶直接修改读取的档案内容，而不是由屏幕输出。 常用命令：123456a ∶新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～c ∶取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！d ∶删除i ∶插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；p ∶列印，亦即将某个选择的资料印出。通常 p 会与参数 sed -n 一起运作s ∶取代，可以直接进行取代！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！ 所以可以通过以下命令进行删除之前查找到的行：1sed -i &apos;69d&apos; ./crealex/init.d/dbus]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>cs61c</tag>
        <tag>linux</tag>
        <tag>diff,sdiff</tag>
        <tag>grep</tag>
        <tag>stat</tag>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK and JRE, java.lang.UnsupportedClassVersionError]]></title>
    <url>%2F2018%2F12%2F21%2FJDK-and-JRE%2F</url>
    <content type="text"><![CDATA[今天我下载了jdk 11.0.1,一番配置后，运行简单的程序时时出现了java.lang.UnsupportedClassVersionError的错误，错误信息如下： 错误信息1234567891011121314151617ajm@DESKTOP-R8SS06A MINGW64 /d/学习/cs61b$ java HelloWorldError: A JNI error has occurred, please check your installation and try againException in thread &quot;main&quot; java.lang.UnsupportedClassVersionError: HelloWorld has been compiled by a more recent version of the Java Runtime (class file version 55.0), this version of the Java Runtime only recognizes class file versions up to 52.0 at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(Unknown Source) at java.security.SecureClassLoader.defineClass(Unknown Source) at java.net.URLClassLoader.defineClass(Unknown Source) at java.net.URLClassLoader.access$100(Unknown Source) at java.net.URLClassLoader$1.run(Unknown Source) at java.net.URLClassLoader$1.run(Unknown Source) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(Unknown Source) at java.lang.ClassLoader.loadClass(Unknown Source) at sun.misc.Launcher$AppClassLoader.loadClass(Unknown Source) at java.lang.ClassLoader.loadClass(Unknown Source) at sun.launcher.LauncherHelper.checkAndLoadMain(Unknown Source) 分析由错误信息可以知道，是由于高版本的JDK(Java Development Kit),编译产生的.class文件在低版本的JRE(Java Runtime Environment) 无法运行而报错。JDK是用于java程序开发的工具包，包含javac编译器、jar打包工具等。JRE是能够让计算机运行java程序的软件包,比如java HelloWorld,执行HelloWorld程序。 查看JDK,JRE版本123456789ajm@DESKTOP-R8SS06A MINGW64 /d/学习/cs61b$ java -versionjava version "1.8.0_171"Java(TM) SE Runtime Environment (build 1.8.0_171-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.171-b11, mixed mode)ajm@DESKTOP-R8SS06A MINGW64 /d/学习/cs61b$ javac -versionjavac 11.0.1 发现JRE是老的版本，于是我直接删除了这个老的版本。但是发现运行时出了问题：123ajm@DESKTOP-R8SS06A MINGW64 /d/学习/cs61b$ java -versionbash: /c/Program Files (x86)/Common Files/Oracle/Java/javapath/java: No such file or directory 这是因为环境变量中的路径问题，直接在PATH中删除老版本java的路径，就能正确找到java 11.0.1这个版本。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[error C2589: (: ::右边的非法标记]]></title>
    <url>%2F2018%2F11%2F25%2Ferror-C2589-%E5%8F%B3%E8%BE%B9%E7%9A%84%E9%9D%9E%E6%B3%95%E6%A0%87%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[原文：https://blog.csdn.net/zhuangshn/article/details/5537499 error C2589: “(”: “::”右边的非法标记 错误输出 error C2589: “(”: “::”右边的非法标记 error C2059: 语法错误 : “::” 错误代码举例 1num_choices = std::max(1, std::min(26, num_choices)); 函数模板max 注：模板就是实现代码重用机制的一种工具，它可以实现类型参数化，即把类型定义为参数， 从而实现了真正的代码可重用性。模版可以分为两类，一个是函数模版，另外一个是类模版。 错误原因 函数模板max与Visual C++中的全局的宏max冲突。 解决办法 第一种办法：设置项目属性，在预定义处理器中添加定义NOMINMAX来禁止使用Vsual C++的min/max宏定义。 项目属性 ——&gt; C/C++ ——&gt; 预处理器 ——&gt; 预处理器定义 (此处添加预定义编译开关 NOMINMAX） 第二种办法： 加上括号，与Vsual C++的min/max宏定义区分开 1num_choices = (std::max)(1, std::min(26, num_choices));]]></content>
      <categories>
        <category>error</category>
      </categories>
      <tags>
        <tag>error</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmake find_path(),windows带空格的路径]]></title>
    <url>%2F2018%2F11%2F25%2Fcmake-find-path-windows%E5%B8%A6%E7%A9%BA%E6%A0%BC%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[cmake中的windows 路径如果有空格，比如D:/Program Files/libigl, 需要改成D:/Program\ Files/libigl12345678910111213141516171819find_path(LIBIGL_INCLUDE_DIR igl/readOBJ.h HINTS ENV LIBIGL ENV LIBIGLROOT ENV LIBIGL_ROOT ENV LIBIGL_DIR PATHS $&#123;CMAKE_SOURCE_DIR&#125;/../.. $&#123;CMAKE_SOURCE_DIR&#125;/.. $&#123;CMAKE_SOURCE_DIR&#125; $&#123;CMAKE_SOURCE_DIR&#125;/libigl $&#123;CMAKE_SOURCE_DIR&#125;/../libigl $&#123;CMAKE_SOURCE_DIR&#125;/../../libigl D:/Program\ Files/libigl /usr /usr/local /usr/local/igl/libigl PATH_SUFFIXES include)]]></content>
      <categories>
        <category>error</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop集群搭建]]></title>
    <url>%2F2018%2F09%2F26%2Fhadoop%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[hadoop 集群搭建实验室当前hadoop集群节点如下： 主机名 用户名 IP 集群中的角色 master hadoop 10.13.61.122 NameNode、JobTracker slave1 hadoop 10.13.61.125 DataNode、TaskTracker slave2 hadoop 10.13.61.132 DataNode、TaskTracker slave3 hadoop 10.13.61.146 DataNode、TaskTracker slave4 hadoop 10.13.61.144 DataNode、TaskTracker slave5 hadoop 10.13.61.143 DataNode、TaskTracker slave6 hadoop 10.13.61.147 DataNode、TaskTracker ajm-zju hadoop 10.13.61.129 DataNode、TaskTracker 各个节点的用户名均设置为 hadoop,密码均为 123456。其中slave3,slave4目前一般不使用。 hadoop集群安装主要有以下几个步骤： 环境配置(host设置，ssh免密登录，Java安装等) hadoop安装及修改配置文件 运行及测试 一、环境配置1. 用户、主机名、hosts文件由于目前已经搭建好的hadoop集群的用户名均为hadoop，所以需要在Ubuntu系统上新建一个hadoop用户，步骤如下： 创建hadoop操作用户1sudo useradd -m hadoop -s /bin/bash 给hadoop用户添加密码1sudo passwd hadoop 输入密码后回车，密码在输入时是不可见的。 给hadoop用户分配sudo权限1sudo adduser hadoop sudo 注销或重启系统，以hadoop用户登录 切换用户1su &lt;用户名&gt;，例如 su hadoop; su ajm 输入要切换的用户密码，即可切换。 安装vim、geditvim是命令行编辑工具，gedit是图形界面编辑器，不习惯vim的话建议使用gedit12sudo apt-get install vimsudo apt-get install gedit 修改主机名不想修改主机名可以跳过此步，不会有影响 在终端中输入hostname可以查看当前主机名，如下图：实际上在终端中有 hadoop@ajm-zju，其中hadoop是用户名，ajm-zju是主机名比如要把新的主机加入集群，为了名称统一，可以将主机名改为 slave7,只需：12sudo hostname slave7 #暂时生效，重启后会失效sudo gedit /etc/hostname 在文件中修改为slave7即可 查看本机ip地址终端中输入以下命令：1ifconfig 图中的 inet地址: 10.13.61.129 即为本机ip地址。 配置hosts/etc/hosts文件里维护了主机名和ip地址的映射关系，这样可以直接通过主机名通信，不用每次输入复杂的ip地址。通过cat命令可以直接在命令行中查看文件内容：1sudo cat /etc/hosts 在我的主机上，结果如下：可以hosts文件中保存了hadoop集群中其他主机的 ip地址主机名 映射关系，这样在hadoop进行通信时，可以直接通过主机名访问。所以如果集群加入新的主机，需要在新主机上修改hosts文件如上图，并加上本机地址映射1sudo gedit /etc/hosts 终端中输入以上命令进行修改 测试如果配置成功，通过 ping 测试时，可以直接通过主机名而不需要ip地址123ping masterping slave1ping 其他主机 成功时结果如下：注：ping指令会一直执行，可以通过 ctrl+C 停止 2. 配置SSH免密登录由于hadoop集群中master主机需要调度各个slave，而这需要配置ssh远程登录服务。 安装sshubuntu 默认安装了ssh 客户端，没有安装服务端。运行：1ps -e|grep ssh 结果应该与下文类似：12hadoop@ajm-zju:/home/ajm$ ps -e|grep ssh 1444 ? 00:00:00 sshd 如果没有 sshd ，则说明没有安装ssh服务端，可以输入以下命令安装：1sudo apt-get install openssh-server ssh登录其他主机1ssh master 出现身份警告时，输入yes并回车，需要输入密码时，请输入master主机的密码。之后就登录了master主机，可以通过命令行操作maseter主机。注：退出登录使用exit 命令。 生成RSA公私钥对但是每次ssh登录都需要输入密码太麻烦，所以可以通过公私钥的方式免密登录，配置方法是 A主机将公钥加入到B主机的authorized_keys中, 则A可以免密登录B。123ssh-keygen -t rsa # 一路回车cd ~/.ssh # 公私钥对保存在此目录ls # 查看目录中的文件列表 终端中输入以上命令后,可以看到有 id_rsa(私钥),id_rsa.pub(公钥)。则将id_rsa.pub追加到master主机的authorized_keys中，则当前主机可以免密登录master主机。1ssh-copy-id -i ~/.ssh/id_rsa.pub master 如需要输入密码则输入master主机的密码 ssh免密登录测试1ssh master 如果直接登录成功，则配置正确。登录master后，由于master主机已经生成了公私钥对，可以将master的公钥发给当前主机,实现master对当前主机的ssh免密登录。1ssh-copy-id -i ~/.ssh/id_rsa.pub &lt;hostname&gt; 如果出现错误，则需要在master主机中修改/etc/hosts，添加新主机的 iphostname 映射。 3. java安装下载 jdk-8u101.linux-x64.tar.gz,运行以下命令解压到/usr目录下:1234sudo mkdir /usr/javasudo tar -zxvf jdk-8u101.linux-x64.tar.gz -C /usr/javacd /usr/java/jdk1.8.0_101/bin./java -version #查看java版本 出现上图结果则正确安装 配置环境变量在前面是通过./java 执行java可执行程序，但是为了执行这个程序，必须每次都切换到/usr/java/jdk1.8.0_101/bin目录下，为了能在任何目录下都能执行java的相关程序，需要配置环境变量。1sudo gedit /etc/profile 在/etc/profile文件末尾添加如下1234export JAVA_HOME=/usr/java/jdk1.8.0_101export JRE_HOME=/usr/java/jdk1.8.0_101/jreexport CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/libexport PATH=$PATH:$JAVA_HOME/bin 保存后退出。通过source命令使得上面的修改生效。1source /etc/profile 输入以下命令测试是否成功配置环境变量1java -version 出现以上结果则成功配置。 二、Hadoop安装1. 安装及环境变量配置安装将hadoop-2.6.0.tar.gz解压到目录/opt123sudo tar -zxvf hadoop-2.6.0.tar.gz -C /opt # 解压到/optcd /opt # 切到含有hadoop-2.6.0的目录下sudo chown -R hadoop:hadoop ./hadoop-2.6.0 # 修改文件权限 配置环境变量与java配置环境变量相同，在/etc/profile中追加：12345export HADOOP_HOME=/opt/hadoop-2.6.0export HADOOP_LIB_NATIVE=$HADOOP_HOME/lib/nativeexport PATH=$PATH:$HADOOP_HOME/binexport PATH=$PATH:$HADOOP_HOME/sbinexport PATH=$PATH:$HADOOP_HOME/lib 保存后退出。通过source命令使得上面的修改生效。1source /etc/profile 输入以下命令测试是否成功配置环境变量1hadoop version 出现以上结果则成功配置。 2. 配置参数需要对所有的集群节点配置参数，其中大部分文件都是相同的，可以配置一个之后直接复制覆盖相关文件，而比如不同主机java安装路径不同的话，需要复制之后修改hadoop-env.sh和yarn-env.sh的相关参数。hadoop需要配置一些参数才能成功运行，这些配置文件都在/opt/hadoop-2.6.0/etc/hadoop/ 目录下。 hadoop-env.sh and yarn-env.sh在hadoop-env.sh和yarn-env.sh中需要指定java安装目录。在文件末尾追加以下内容即可：1export JAVA_HOME=/usr/java/jdk1.8.0_101 slavesslaves文件需要添加所有的slave节点主机名如下：12345678slave1slave2slave3slave4slave5slave6ajm-zju&lt;Your hostname&gt; core-site.xml添加以下内容：12345678910111213141516&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://master:8020&lt;/value&gt; &lt;description&gt;&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;io.file.buffer.size&lt;/name&gt; &lt;value&gt;131072&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/opt/hadoop-2.6.0/tmp&lt;/value&gt; &lt;description&gt;A base for other temporary directories.&lt;/description&gt; &lt;/property&gt;&lt;/configuration&gt; hdfs-site.xml这个文件配置hdfs文件系统相关参数，添加以下内容：1234567891011121314151617181920212223242526272829&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;3&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/opt/hadoop-2.6.0/dfs/name&lt;/value&gt; &lt;description&gt;namenode上存储hdfs name空间元数据&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/opt/hadoop-2.6.0/dfs/data&lt;/value&gt; &lt;description&gt;datanode上数据块的物理存储位置&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt; &lt;value&gt;master:50090&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.permissions&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; mapred-site.xml这个文件配置mapreduce任务相关参数。首先需要重命名mapred-site.xml.template文件：1mv ./mapred-site.xml.template mapred-site.xml 然后将以下内容添加到 mapred-site.xml:12345678910111213141516171819202122232425262728293031&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt; &lt;value&gt;master:10020&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt; &lt;value&gt;master:19888&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.itermediate-done-dir&lt;/name&gt; &lt;value&gt;$&#123;hadoop.tmp.dir&#125;/mr-history/tmp&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.done-dir&lt;/name&gt; &lt;value&gt;$&#123;hadoop.tmp.dir&#125;/mr-history/done&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobtracker.staging.root.dir&lt;/name&gt; &lt;value&gt;/user&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; yarn-site.xml这个文件配置yarn资源管理调度的相关参数,添加以下内容：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class&lt;/name&gt; &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt; &lt;value&gt;master:8032&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt; &lt;value&gt;master:8030&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt; &lt;value&gt;master:8035&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.admin.address&lt;/name&gt; &lt;value&gt;master:8033&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt; &lt;value&gt;master:8088&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.app.mapreduce.am.staging-dir&lt;/name&gt; &lt;value&gt;/user&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt; &lt;value&gt;20480&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.scheduler.minimum-allocation-mb&lt;/name&gt; &lt;value&gt;2048&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.vmem-pmem-ratio&lt;/name&gt; &lt;value&gt;2.1&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 三、 运行及测试ssh登录master主机后，进行以下操作。 格式化分布式文件系统(已有hadoop系统请跳过这一步)只有在第一次搭建hadoop系统时需要进行格式化操作，请不要在已有的hadoop系统上格式化，这会删除所有的数据！！！! 1hdfs namenode -format 运行文件系统管理器hdfs1start-dfs.sh 运行任务调度管理器yarn1start-yarn.sh 查看相关进程1jps 在master中可以看到：123456[hadoop@master ~]$ jps5859 SecondaryNameNode6003 ResourceManager6293 Jps24991 JobHistoryServer5695 NameNode 在各个slave中可以看到：1234hadoop@ajm-zju:/$ jps28976 DataNode31952 NodeManager32158 Jps Web查看信息在web上可以看到集群启动的信息： 查看hdfs: master:50070 查看resourcemanager: master:8088 如果web页面访问不了，可能是master主机的防火墙未关闭, ssh登录master主机,运行以下命令：1sudo systemctl status firewalld.service # 查看防火墙状态 若图中的Active:显示为active，则需要关闭防火墙。1sudo systemctl stop firewalld.service # 关闭防火墙 关闭后重新访问页面即可。 关闭hadoop执行相反的操作12stop-yarn.shstop-dfs.sh 本文引用了以下内容 Hadoop真分布式集群最速搭建攻略]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
</search>
